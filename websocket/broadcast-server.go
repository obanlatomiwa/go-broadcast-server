package websocket

import (
	"log"
	"sync"
)

type BroadCastServer struct {
	sync.RWMutex
	clients    map[*Client]bool
	broadcast  chan *Message
	register   chan *Client
	unregister chan *Client
	messages   []*Message
	listenAddr string
}

type Message struct {
	clientId string
	data     string
}

func NewBroadCastServer(broadcastAddr string) *BroadCastServer {
	return &BroadCastServer{
		clients:    make(map[*Client]bool),
		broadcast:  make(chan *Message),
		register:   make(chan *Client),
		unregister: make(chan *Client),
		listenAddr: broadcastAddr,
	}
}

func (server *BroadCastServer) StartBroadCast() {
	for {
		select {
		case client := <-server.register:
			server.Lock()
			// NB: Maps in Golang are not concurrency safe, so use a mutex to avoid race conditions
			server.clients[client] = true
			log.Printf("Client registed to broadcast %s", client.id)
			server.Unlock()

			for _, msg := range server.messages {
				client.send <- getMessage(client.id, msg)
			}

		case client := <-server.unregister:
			server.Lock()
			if _, ok := server.clients[client]; ok {
				close(client.send)
				delete(server.clients, client)
				log.Printf("Client unregister from broadcast %s", client.id)
			}
			server.Unlock()

		case message := <-server.broadcast:
			server.RLock()
			server.messages = append(server.messages, message)

			// broadcast to all the clients
			for client := range server.clients {
				log.Printf("Broadcasting to client %s ", client.id)
				select {
				case client.send <- getMessage(client.id, message):
				default:
					close(client.send)
					delete(server.clients, client)

				}
			}
			server.RUnlock()
		}
	}
}

// if the message was generated by a client, the client should not get the message broadcasted back to itself
func getMessage(clientId string, message *Message) []byte {
	if message.clientId == clientId {
		return []byte{}
	}
	return []byte(message.data)
}
