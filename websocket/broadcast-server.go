package websocket

import (
	"fmt"
	"github.com/obanlatomiwa/go-broadcast-server/utils"
	"log"
	"net/http"
	"os"
	"os/signal"
	"sync"
)

type BroadCastServer struct {
	sync.RWMutex
	clients    map[*Client]bool
	broadcast  chan *Message
	register   chan *Client
	unregister chan *Client
	messages   []*Message
	listenAddr string
}

type Message struct {
	clientId string
	data     string
}

var server *BroadCastServer

func InitiateBroadCast() {
	fmt.Println("Initiate broadcast")

	PORT := utils.GetValueFromConfigFile("APP_PORT")
	server = NewBroadCastServer(PORT)
	go server.StartBroadCast()

	http.HandleFunc("/ws", func(w http.ResponseWriter, r *http.Request) {
		StartWebsocketConnection(server, w, r)
	})

	err := http.ListenAndServe(fmt.Sprintf(":%s", PORT), nil)
	if err != nil {
		return
	}
}

func StopBroadCast() {
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt)
}

func NewBroadCastServer(broadcastAddr string) *BroadCastServer {
	return &BroadCastServer{
		clients:    make(map[*Client]bool),
		broadcast:  make(chan *Message),
		register:   make(chan *Client),
		unregister: make(chan *Client),
		listenAddr: broadcastAddr,
	}
}

func (server *BroadCastServer) StartBroadCast() {
	for {
		select {
		case client := <-server.register:
			server.Lock()
			// NB: Maps in Golang are not concurrency safe, so use a mutex to avoid race conditions
			server.clients[client] = true
			log.Printf("Client registed to broadcast %s", client.id)
			server.Unlock()

			for _, msg := range server.messages {
				client.send <- getMessage(client.id, msg)
			}

		case client := <-server.unregister:
			server.Lock()
			if _, ok := server.clients[client]; ok {
				close(client.send)
				delete(server.clients, client)
				log.Printf("Client unregister from broadcast %s", client.id)
			}
			server.Unlock()

		case message := <-server.broadcast:
			server.RLock()
			server.messages = append(server.messages, message)

			// broadcast to all the clients
			for client := range server.clients {
				log.Printf("Broadcasting to client %s ", client.id)
				select {
				case client.send <- getMessage(client.id, message):
				default:
					close(client.send)
					delete(server.clients, client)

				}
			}
			server.RUnlock()
		}
	}
}

// if the message was generated by a client, the client should not get the message broadcasted back to itself
func getMessage(clientId string, message *Message) []byte {
	if message.clientId == clientId {
		return []byte{}
	}
	return []byte(message.data)
}

func GetAllClients() {
	fmt.Println("All clients connected to the broadcast server...")
	for client := range server.clients {
		fmt.Println(client.id)
	}
}
